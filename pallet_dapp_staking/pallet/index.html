<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `pallet` module in each FRAME pallet hosts the most important items needed to construct this pallet."><title>pallet_dapp_staking::pallet - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pallet_dapp_staking" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../pallet_dapp_staking/index.html">pallet_dapp_staking</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module pallet</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate pallet_dapp_staking</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../pallet_dapp_staking/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">pallet_dapp_staking</a>::<wbr><a class="mod" href="#">pallet</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/pallet_dapp_staking/lib.rs.html#94">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</p>
<p>The main components of this pallet are:</p>
<ul>
<li><a href="struct.Pallet.html" title="struct pallet_dapp_staking::pallet::Pallet"><code>Pallet</code></a>, which implements all of the dispatchable extrinsics of the pallet, among
other public functions.
<ul>
<li>The subset of the functions that are dispatchable can be identified either in the
<a href="dispatchables/index.html" title="mod pallet_dapp_staking::pallet::dispatchables"><code>dispatchables</code></a> module or in the <a href="enum.Call.html" title="enum pallet_dapp_staking::pallet::Call"><code>Call</code></a> enum.</li>
</ul>
</li>
<li><a href="storage_types/index.html" title="mod pallet_dapp_staking::pallet::storage_types"><code>storage_types</code></a>, which contains the list of all types that are representing a
storage item. Otherwise, all storage items are listed among <a href="#types"><em>Type Definitions</em></a>.</li>
<li><a href="trait.Config.html" title="trait pallet_dapp_staking::pallet::Config"><code>Config</code></a>, which contains the configuration trait of this pallet.</li>
<li><a href="enum.Event.html" title="enum pallet_dapp_staking::pallet::Event"><code>Event</code></a> and <a href="enum.Error.html" title="enum pallet_dapp_staking::pallet::Error"><code>Error</code></a>, which are listed among the <a href="#enums"><em>Enums</em></a>.</li>
</ul>
<h2 id="dapp-staking-v3"><a class="doc-anchor" href="#dapp-staking-v3">§</a>dApp Staking v3</h2><h3 id="introduction"><a class="doc-anchor" href="#introduction">§</a>Introduction</h3>
<p>Astar and Shiden networks provide a unique way for developers to earn rewards by developing products that native token holders decide to support.</p>
<p>The principle is simple - stakers lock their tokens to <em>stake</em> on a dApp, and if the dApp attracts enough support, it is rewarded in native currency, derived from the inflation.
In turn stakers are rewarded for locking &amp; staking their tokens.</p>
<h3 id="functionality-overview"><a class="doc-anchor" href="#functionality-overview">§</a>Functionality Overview</h3><h4 id="eras"><a class="doc-anchor" href="#eras">§</a>Eras</h4>
<p>Eras are the basic <em>time unit</em> in dApp staking and their length is measured in the number of blocks.</p>
<p>They are not expected to last long, e.g. current live networks era length is roughly 1 day (7200 blocks).
After an era ends, it’s usually possible to claim rewards for it, if user or dApp are eligible.</p>
<h4 id="periods"><a class="doc-anchor" href="#periods">§</a>Periods</h4>
<p>Periods are another <em>time unit</em> in dApp staking. They are expected to be more lengthy than eras.</p>
<p>Each period consists of two subperiods:</p>
<ul>
<li><code>Voting</code></li>
<li><code>Build&amp;Earn</code></li>
</ul>
<p>Each period is denoted by a number, which increments each time a new period begins.
Period beginning is marked by the <code>voting</code> subperiod, after which follows the <code>build&amp;earn</code> period.</p>
<p>Stakes are <strong>only</strong> valid throughout a period. When new period starts, all stakes are reset to <strong>zero</strong>. This helps prevent projects remaining staked due to intertia of stakers, and makes for a more dynamic staking system. Staker doesn’t need to do anything for this to happen, it is automatic.</p>
<p>Even though stakes are reset, locks (or freezes) of tokens remain.</p>
<h5 id="voting"><a class="doc-anchor" href="#voting">§</a>Voting</h5>
<p>When <code>Voting</code> subperiod starts, all <em>stakes</em> are reset to <strong>zero</strong>.
Projects participating in dApp staking are expected to market themselves to (re)attract stakers.</p>
<p>Stakers must assess whether the project they want to stake on brings value to the ecosystem, and then <code>vote</code> for it.
Casting a vote, or staking, during the <code>Voting</code> subperiod makes the staker eligible for bonus rewards. so they are encouraged to participate.</p>
<p><code>Voting</code> subperiod length is expressed in <em>standard</em> era lengths, even though the entire voting subperiod is treated as a single <em>voting era</em>.
E.g. if <code>voting</code> subperiod lasts for <strong>5 eras</strong>, and each era lasts for <strong>100</strong> blocks, total length of the <code>voting</code> subperiod will be <strong>500</strong> blocks.</p>
<ul>
<li>Block 1, Era 1 starts, Period 1 starts, <code>Voting</code> subperiod starts</li>
<li>Block 501, Era 2 starts, Period 1 continues, <code>Build&amp;Earn</code> subperiod starts</li>
</ul>
<p>Neither stakers nor dApps earn rewards during this subperiod - no new rewards are generated after <code>voting</code> subperiod ends.</p>
<h5 id="buildearn"><a class="doc-anchor" href="#buildearn">§</a>Build&amp;Earn</h5>
<p><code>Build&amp;Earn</code> subperiod consits of one or more eras, therefore its length is expressed in eras.</p>
<p>After each <em>era</em> ends, eligible stakers and dApps can claim the rewards they earned. Rewards are <strong>only</strong> claimable for the finished eras.</p>
<p>It is still possible to <em>stake</em> during this period, and stakers are encouraged to do so since this will increase the rewards they earn.
The only exemption is the <strong>final era</strong> of the <code>build&amp;earn</code> subperiod - it’s not possible to <em>stake</em> then since the stake would be invalid anyhow (stake is only valid from the next era which would be in the next period).</p>
<p>To continue the previous example where era length is <strong>100</strong> blocks, let’s assume that <code>Build&amp;Earn</code> subperiod lasts for 10 eras:</p>
<ul>
<li>Block 1, Era 1 starts, Period 1 starts, <code>Voting</code> subperiod starts</li>
<li>Block 501, Era 2 starts, Period 1 continues, <code>Build&amp;Earn</code> subperiod starts</li>
<li>Block 601, Era 3 starts, Period 1 continues, <code>Build&amp;Earn</code> subperiod continues</li>
<li>Block 701, Era 4 starts, Period 1 continues, <code>Build&amp;Earn</code> subperiod continues</li>
<li>…</li>
<li>Block 1401, Era 11 starts, Period 1 continues, <code>Build&amp;Earn</code> subperiod enters the final era</li>
<li>Block 1501, Era 12 starts, Period 2 starts, <code>Voting</code> subperiod starts</li>
<li>Block 2001, Era 13 starts, Period 2 continues, <code>Build&amp;Earn</code> subperiod starts</li>
</ul>
<h4 id="dapps--smart-contracts"><a class="doc-anchor" href="#dapps--smart-contracts">§</a>dApps &amp; Smart Contracts</h4>
<p>Protocol is called dApp staking, but internally it essentially works with smart contracts, or even more precise, smart contract addresses.</p>
<p>Throughout the code, when addressing a particular dApp, it’s addressed as <code>smart contract</code>. Naming of the types &amp; storage more closely follows <code>dApp</code> nomenclature.</p>
<h5 id="registration"><a class="doc-anchor" href="#registration">§</a>Registration</h5>
<p>Projects, or <em>dApps</em>, must be registered into protocol to participate.
Only a privileged <code>ManagerOrigin</code> can perform dApp registration.
The pallet itself does not make assumptions who the privileged origin is, and it can differ from runtime to runtime.</p>
<p>Once dApp has been registered, stakers can stake on it immediatelly.</p>
<p>When contract is registered, it is assigned a unique compact numeric Id - 16 bit unsigned integer. This is important for the inner workings of the pallet, and is not directly exposed to the users.</p>
<p>There is a limit of how many smart contracts can be registered at once. Once the limit is reached, any additional attempt to register a new contract will fail.</p>
<h5 id="reward-beneficiary--ownership"><a class="doc-anchor" href="#reward-beneficiary--ownership">§</a>Reward Beneficiary &amp; Ownership</h5>
<p>After a dApp has been registered, it is possible to modify reward beneficiary or even the owner of the dApp. The owner can perform reward delegation and can further transfer ownership.</p>
<h5 id="unregistration"><a class="doc-anchor" href="#unregistration">§</a>Unregistration</h5>
<p>dApp can be removed from the procotol by unregistering it.
This is a privileged action that only <code>ManagerOrigin</code> can perform.</p>
<p>After a dApp has been unregistered, it’s no longer eligible to receive rewards.
It’s still possible however to claim past unclaimed rewards.</p>
<p>Important to note that even if dApp has been unregistered, it still occupies a <em>slot</em>
in the dApp staking protocol and counts towards maximum number of registered dApps.
This will be improved in the future when dApp data will be cleaned up after some time.</p>
<h4 id="stakers"><a class="doc-anchor" href="#stakers">§</a>Stakers</h4><h5 id="locking-tokens"><a class="doc-anchor" href="#locking-tokens">§</a>Locking Tokens</h5>
<p>In order for users to participate in dApp staking, the first step they need to take is lock (or freeze) some native currency. Reserved tokens cannot be locked, but tokens locked by another lock can be re-locked into dApp staking (double locked).</p>
<p><strong>NOTE:</strong> Locked funds cannot be used for paying fees, or for transfer.</p>
<p>In order to participate, user must have a <code>MinimumLockedAmount</code> of native currency locked. This doesn’t mean that they cannot lock <em>less</em> in a single call, but total locked amount must always be equal or greater than <code>MinimumLockedAmount</code>.</p>
<p>In case amount specified for locking is greater than what user has available, only what’s available will be locked.</p>
<h5 id="unlocking-tokens"><a class="doc-anchor" href="#unlocking-tokens">§</a>Unlocking Tokens</h5>
<p>User can at any time decide to unlock their tokens. However, it’s not possible to unlock tokens which are staked, so user has to unstake them first.</p>
<p>Once <em>unlock</em> is successfully executed, the tokens aren’t immediately unlocked, but instead must undergo the unlocking process. Once unlocking process has finished, user can <em>claim</em> their unlocked tokens into their free balance.</p>
<p>There is a limited number of <code>unlocking chunks</code> a user can have at any point in time. If limit is reached, user must claim existing unlocked chunks, or wait for them to be unlocked before claiming them to free up space for new chunks.</p>
<p>In case calling unlocking some amount would take the user below the <code>MinimumLockedAmount</code>, <strong>everything</strong> will be unlocked.</p>
<p>For users who decide they would rather re-lock their tokens then wait for the unlocking process to finish, there’s an option to do so. All currently unlocking chunks are consumed, and added back into locked amount.</p>
<h5 id="staking-tokens"><a class="doc-anchor" href="#staking-tokens">§</a>Staking Tokens</h5>
<p>Locked tokens, which aren’t being used for staking, can be used to stake on a dApp. This translates to <em>voting</em> or <em>nominating</em> a dApp to receive rewards derived from the inflation. User can stake on multiple dApps if they want to.</p>
<p>The staked amount <strong>must be precise</strong>, no adjustment will be made by the pallet in case a too large amount is specified.</p>
<p>The staked amount is only eligible for rewards from the next era - in other words, only the amount that has been staked for the entire era is eligible to receive rewards.</p>
<p>It is not possible to stake if there are unclaimed rewards from past eras. User must ensure to first claim their pending rewards, before staking. This is also beneficial to the users since it allows them to lock &amp; stake the earned rewards as well.</p>
<p>User’s stake on a contract must be equal or greater than the <code>MinimumStakeAmount</code>. This is similar to the minimum lock amount, but this limit is per contract.</p>
<p>Although user can stake on multiple smart contracts, the amount is limited. To be more precise, amount of database entries that can exist per user is limited.</p>
<p>The protocol keeps track of how much was staked by the user in <code>voting</code> and <code>build&amp;earn</code> subperiod. This is important for the bonus reward calculation.</p>
<p>It is not possible to stake on a dApp that has been unregistered.
However, if dApp is unregistered after user has staked on it, user will keep earning
rewards for the staked amount, or can ‘move’ his stake without impacting his number of allowed <em>safe move actions</em> for the ongoing period.</p>
<h5 id="unstaking-tokens"><a class="doc-anchor" href="#unstaking-tokens">§</a>Unstaking Tokens</h5>
<p>User can at any time decide to unstake staked tokens. There’s no <em>unstaking</em> process associated with this action.</p>
<p>Unlike stake operation, which stakes from the <em>next</em> era, unstake will reduce the staked amount for the current and next era if stake exists.</p>
<p>Same as with stake operation, it’s not possible to unstake anything until unclaimed rewards have been claimed. User must ensure to first claim all rewards, before attempting to unstake. Unstake amount must also be precise as no adjustment will be done to the amount.</p>
<p>The amount unstaked will always first reduce the amount staked in the ongoing subperiod. E.g. if <code>voting</code> subperiod has stake of <strong>100</strong>, and <code>build&amp;earn</code> subperiod has stake of <strong>50</strong>, calling unstake with amount <strong>70</strong> during <code>build&amp;earn</code> subperiod will see <code>build&amp;earn</code> stake amount reduced to <strong>zero</strong>, while <code>voting</code> stake will be reduced to <strong>80</strong>.</p>
<p>If unstake would reduce the staked amount below <code>MinimumStakeAmount</code>, everything is unstaked.</p>
<p>Once period finishes, all stakes are reset back to zero. This means that no unstake operation is needed after period ends to <em>unstake</em> funds - it’s done automatically.</p>
<p>During the <code>Build&amp;Earn</code> subperiod, if unstaking reduces the voting stake, the bonus status will be updated, and the number of allowed <em>move actions</em> for the ongoing period will be reduced.</p>
<p>Any forfeited bonus is converted into <code>Build&amp;Earn</code> stake, ensuring that voting amounts are not lost but instead reallocated appropriately.</p>
<p>If dApp has been unregistered, a special operation to unstake from unregistered contract must be used that preserves bonus elegibility.</p>
<h5 id="moving-stake-between-contracts"><a class="doc-anchor" href="#moving-stake-between-contracts">§</a>Moving Stake Between Contracts</h5>
<p>The moving stake feature allows users to transfer their staked amount between two smart contracts without undergoing the unstake and stake process separately. This feature ensures that the transferred stake remains aligned with the current staking period (effective in the next era), and any bonus eligibility is preserved as long as the conditions for the bonus reward are not violated (move actions are limited by <code>MaxBonusSafeMovesPerPeriod</code>).</p>
<p>Key details about moving stake:</p>
<ul>
<li>The destination contract must be different from the source contract.</li>
<li>The user must ensure that unclaimed rewards are claimed before initiating a stake move.</li>
<li>Only a limited number of move actions (defined by <code>MaxBonusSafeMovesPerPeriod</code>) are allowed during a single period to preserve bonus reward eligibility (check “Claiming Bonus Reward” section below).</li>
<li>If the destination contract is newly staked, the user’s total staked contracts must not exceed the maximum allowed number of staked contracts.</li>
<li>The destination contract must not be unregistered, but moving stake away from an unregistered contract is allowed without affecting bonus eligibility.</li>
</ul>
<p>This feature is particularly useful for stakers who wish to rebalance their stake across multiple contracts (including new registrations) or move their stake to better-performing dApps while retaining the potential for rewards and maintaining bonus eligibility.</p>
<h5 id="bonus-status-handling-in-moves"><a class="doc-anchor" href="#bonus-status-handling-in-moves">§</a>Bonus Status Handling in Moves</h5>
<p>When moving stake, if the destination contract has no existing bonus eligibility, it inherits the incoming bonus status from the source contract. If both the source and destination have nonzero bonus statuses, they are merged by averaging their values. This prevents unintended bonus gains or losses while ensuring fairness in bonus distribution.</p>
<p>For example, if the configuration allows <strong>2</strong> safe moves, the default bonus status starts at <strong>3</strong>. If the source contract’s bonus status decreases from <strong>3</strong> to <strong>1</strong> after an unstake and the move operation, and the destination contract retains the default <strong>3</strong>, the new bonus status is calculated as: <strong>(1 + 3) / 2</strong>, resulting into <strong>2</strong>.
This ensures a smooth and fair adjustment while keeping stake amounts properly aligned.</p>
<h5 id="claiming-staker-rewards"><a class="doc-anchor" href="#claiming-staker-rewards">§</a>Claiming Staker Rewards</h5>
<p>Stakers can claim rewards for passed eras during which they were staking. Even if multiple contracts were staked, claim reward call will claim rewards for all of them.</p>
<p>Only rewards for passed eras can be claimed. It is possible that a successful reward claim call will claim rewards for multiple eras. This can happen if staker hasn’t claimed rewards in some time, and many eras have passed since then, accumulating pending rewards.</p>
<p>To achieve this, the pallet’s underyling storage organizes <strong>era reward information</strong> into <strong>spans</strong>. A single span covers multiple eras, e.g. from <strong>1</strong> to <strong>16</strong>. In case user has staked during era 1, and hasn’t claimed rewards until era 17, they will be eligible to claim 15 rewards in total (from era 2 to 16). All of this will be done in a single claim reward call.</p>
<p>In case unclaimed history has built up past one span, multiple reward claim calls will be needed to claim all of the rewards.</p>
<p>Rewards don’t remain available forever, and if not claimed within some time period, they will be treated as expired. This will be a longer period, but will still exist.</p>
<p>Rewards are calculated using a simple formula: <code>staker_reward_pool * staker_staked_amount / total_staked_amount</code>.</p>
<h5 id="claiming-bonus-reward"><a class="doc-anchor" href="#claiming-bonus-reward">§</a>Claiming Bonus Reward</h5>
<p>If a staker has staked on a dApp during the voting subperiod, and the bonus status for the associated staked amount has not been forfeited due to excessive move actions, they remain eligible for the bonus reward.</p>
<p>Only a limited number of <em>safe move actions</em> are allowed during the <code>build&amp;earn</code> subperiod to preserve bonus reward eligibility. Move actions refer to either:</p>
<ul>
<li>A ‘partial unstake that decreases the voting stake’,</li>
<li>A ‘stake transfer between two contracts’. (check previous “Moving Stake Between Contracts” section)</li>
</ul>
<p>The number of authorized safe move actions is defined by <code>MaxBonusSafeMovesPerPeriod</code>. For example:
If 2 safe bonus move actions are allowed for one period, and a user has staked <strong>100</strong> on contract A during the <code>voting</code> subperiod and <strong>50</strong> during the <code>build&amp;earn</code> subperiod, they can safely:</p>
<ol>
<li>Unstake <strong>70</strong>, reducing the <code>voting</code> stake to <strong>80</strong>.</li>
<li>Transfer <strong>50</strong> to contract B.</li>
</ol>
<p>After these actions, the user will still be eligible for bonus rewards (<strong>20</strong> on contract A and <strong>50</strong> on contract B). However, if an additional move action is performed on contract A, the bonus eligibility will be forfeited.</p>
<p>Bonus rewards need to be claimed per contract, unlike staker rewards.</p>
<p>Bonus reward is calculated using a simple formula: <code>bonus_reward_pool * staker_voting_subperiod_stake / total_voting_subperiod_stake</code>.</p>
<h5 id="handling-expired-entries"><a class="doc-anchor" href="#handling-expired-entries">§</a>Handling Expired Entries</h5>
<p>There is a limit to how much contracts can a staker stake on at once.
Or to be more precise, for how many contract a database entry can exist at once.</p>
<p>It’s possible that stakers get themselves into a situation where some number of expired database entries associated to
their account has accumulated. In that case, it’s required to call a special extrinsic to cleanup these expired entries.</p>
<h4 id="developers"><a class="doc-anchor" href="#developers">§</a>Developers</h4>
<p>Main thing for developers to do is develop a good product &amp; attract stakers to stake on them.</p>
<h5 id="claiming-dapp-reward"><a class="doc-anchor" href="#claiming-dapp-reward">§</a>Claiming dApp Reward</h5>
<p>If at the end of an build&amp;earn subperiod era dApp has high enough score to enter a tier, it gets rewards assigned to it.
Rewards aren’t paid out automatically but must be claimed instead, similar to staker &amp; bonus rewards.</p>
<p>When dApp reward is being claimed, both smart contract &amp; claim era must be specified.</p>
<p>dApp reward is calculated based on the tier in which ended. All dApps that end up in one tier will get the exact same reward.</p>
<h4 id="tier-system"><a class="doc-anchor" href="#tier-system">§</a>Tier System</h4>
<p>At the end of each build&amp;earn subperiod era, dApps are evaluated using a simple metric - total value staked on them.
Based on this metric, they are sorted, and assigned to tiers.</p>
<p>There is a limited number of tiers, and each tier has a limited capacity of slots.
Each tier also has a <em>threshold</em> which a dApp must satisfy in order to enter it. Thresholds for each tier are dynamically calculated as percentages of the total issuance at the time of the dApp staking v3 launch.</p>
<p>Better tiers bring bigger rewards, so dApps are encouraged to compete for higher tiers and attract staker’s support.
For each tier, the reward pool and capacity are fixed. Each dApp within a tier always gets the same amount of reward.
Even if tier capacity hasn’t been fully taken, rewards are paid out as if they were.</p>
<p>For example, if tier 1 has capacity for 10 dApps, and reward pool is <strong>500 ASTR</strong>, it means that each dApp that ends up
in this tier will earn <strong>50 ASTR</strong>. Even if only 3 dApps manage to enter this tier, they will still earn each <strong>50 ASTR</strong>.
The rest, <strong>350 ASTR</strong> in this case, won’t be minted (or will be <em>burned</em> if the reader prefers such explanation).</p>
<p>If there are more dApps eligible for a tier than there is capacity, the dApps with the higher score get the advantage.
dApps which missed out get priority for entry into the next lower tier (if there still is any).</p>
<p>In the case a dApp doesn’t satisfy the entry threshold for any tier, even though there is still capacity, the dApp will simply
be left out of tiers and won’t earn <strong>any</strong> reward.</p>
<p>In a special and unlikely case that two or more dApps have the exact same score and satisfy tier entry threshold, but there isn’t enough
leftover tier capacity to accomodate them all, this is considered <em>undefined</em> behavior. Some of the dApps will manage to enter the tier, while
others will be left out. There is no strict rule which defines this behavior - instead dApps are encouraged to ensure their tier entry by
having a larger stake than the other dApp(s). Tehnically, at the moment, the dApp with the lower <code>dApp Id</code> will have the advantage over a dApp with
the larger Id.</p>
<h4 id="reward-expiry"><a class="doc-anchor" href="#reward-expiry">§</a>Reward Expiry</h4>
<p>Unclaimed rewards aren’t kept indefinitely in storage. Eventually, they expire.
Stakers &amp; developers should make sure they claim those rewards before this happens.</p>
<p>In case they don’t, they will simply miss on the earnings.</p>
<p>However, this should not be a problem given how the system is designed.
There is no longer <em>stake&amp;forger</em> - users are expected to revisit dApp staking at least at the
beginning of each new period to pick out old or new dApps on which to stake on.
If they don’t do that, they miss out on the bonus reward &amp; won’t earn staker rewards.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.tt_error_token"><code>pub use __tt_error_token_1 as tt_error_token;</code></div></li><li><div class="item-name" id="reexport.tt_default_parts"><code>pub use __tt_default_parts_7 as tt_default_parts;</code></div></li><li><div class="item-name" id="reexport.tt_extra_parts"><code>pub use __tt_extra_parts_7 as tt_extra_parts;</code></div></li><li><div class="item-name" id="reexport.tt_default_parts_v2"><code>pub use __tt_default_parts_v2_7 as tt_default_parts_v2;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="dispatchables/index.html" title="mod pallet_dapp_staking::pallet::dispatchables">dispatchables</a></div><div class="desc docblock-short">Auto-generated docs-only module listing all defined dispatchables for this pallet.</div></li><li><div class="item-name"><a class="mod" href="storage_types/index.html" title="mod pallet_dapp_staking::pallet::storage_types">storage_types</a></div><div class="desc docblock-short">Auto-generated docs-only module listing all (public and private) defined storage types
for this pallet.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DefaultSafeguard.html" title="struct pallet_dapp_staking::pallet::DefaultSafeguard">DefaultSafeguard</a></div></li><li><div class="item-name"><a class="struct" href="struct.GenesisConfig.html" title="struct pallet_dapp_staking::pallet::GenesisConfig">GenesisConfig</a></div><div class="desc docblock-short">Can be used to configure the
<a href="https://docs.substrate.io/build/genesis-configuration/">genesis state</a>
of this pallet.</div></li><li><div class="item-name"><a class="struct" href="struct.Pallet.html" title="struct pallet_dapp_staking::pallet::Pallet">Pallet</a></div><div class="desc docblock-short">The <code>Pallet</code> struct, the main type that implements traits and standalone
functions within the pallet.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Call.html" title="enum pallet_dapp_staking::pallet::Call">Call</a></div><div class="desc docblock-short">Contains a variant per dispatchable extrinsic that this pallet has.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum pallet_dapp_staking::pallet::Error">Error</a></div><div class="desc docblock-short">The <code>Error</code> enum of this pallet.</div></li><li><div class="item-name"><a class="enum" href="enum.Event.html" title="enum pallet_dapp_staking::pallet::Event">Event</a></div><div class="desc docblock-short">The <code>Event</code> enum of this pallet</div></li><li><div class="item-name"><a class="enum" href="enum.FreezeReason.html" title="enum pallet_dapp_staking::pallet::FreezeReason">FreezeReason</a></div><div class="desc docblock-short">A reason for freezing funds.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.STORAGE_VERSION.html" title="constant pallet_dapp_staking::pallet::STORAGE_VERSION">STORAGE_VERSION</a></div><div class="desc docblock-short">The current storage version.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Config.html" title="trait pallet_dapp_staking::pallet::Config">Config</a></div><div class="desc docblock-short">Configuration trait of this pallet.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.__type_value_for_default_safeguard.html" title="fn pallet_dapp_staking::pallet::__type_value_for_default_safeguard">__type_value_for_default_safeguard</a></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ActiveBonusUpdateState.html" title="type pallet_dapp_staking::pallet::ActiveBonusUpdateState">ActiveBonusUpdateState</a></div><div class="desc docblock-short">Temporary cursor to persist latest BonusStatus item updated.
TODO: remove it once all BonusStatus are updated and this storage value is cleanup.</div></li><li><div class="item-name"><a class="type" href="type.ActiveProtocolState.html" title="type pallet_dapp_staking::pallet::ActiveProtocolState">ActiveProtocolState</a></div><div class="desc docblock-short">General information about dApp staking protocol state.</div></li><li><div class="item-name"><a class="type" href="type.ContractStake.html" title="type pallet_dapp_staking::pallet::ContractStake">ContractStake</a></div><div class="desc docblock-short">Information about how much has been staked on a smart contract in some era or period.</div></li><li><div class="item-name"><a class="type" href="type.CurrentEraInfo.html" title="type pallet_dapp_staking::pallet::CurrentEraInfo">CurrentEraInfo</a></div><div class="desc docblock-short">General information about the current era.</div></li><li><div class="item-name"><a class="type" href="type.DAppTiers.html" title="type pallet_dapp_staking::pallet::DAppTiers">DAppTiers</a></div><div class="desc docblock-short">Information about which tier a dApp belonged to in a specific era.</div></li><li><div class="item-name"><a class="type" href="type.EraRewards.html" title="type pallet_dapp_staking::pallet::EraRewards">EraRewards</a></div><div class="desc docblock-short">Information about rewards for each era.</div></li><li><div class="item-name"><a class="type" href="type.HistoryCleanupMarker.html" title="type pallet_dapp_staking::pallet::HistoryCleanupMarker">HistoryCleanupMarker</a></div><div class="desc docblock-short">History cleanup marker - holds information about which DB entries should be cleaned up next, when applicable.</div></li><li><div class="item-name"><a class="type" href="type.IntegratedDApps.html" title="type pallet_dapp_staking::pallet::IntegratedDApps">IntegratedDApps</a></div><div class="desc docblock-short">Map of all dApps integrated into dApp staking protocol.</div></li><li><div class="item-name"><a class="type" href="type.Ledger.html" title="type pallet_dapp_staking::pallet::Ledger">Ledger</a></div><div class="desc docblock-short">General locked/staked information for each account.</div></li><li><div class="item-name"><a class="type" href="type.Module.html" title="type pallet_dapp_staking::pallet::Module">Module</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Type alias to <code>Pallet</code>, to be used by <code>construct_runtime</code>.</div></li><li><div class="item-name"><a class="type" href="type.NextDAppId.html" title="type pallet_dapp_staking::pallet::NextDAppId">NextDAppId</a></div><div class="desc docblock-short">Counter for unique dApp identifiers.</div></li><li><div class="item-name"><a class="type" href="type.PeriodEnd.html" title="type pallet_dapp_staking::pallet::PeriodEnd">PeriodEnd</a></div><div class="desc docblock-short">Information about period’s end.</div></li><li><div class="item-name"><a class="type" href="type.Safeguard.html" title="type pallet_dapp_staking::pallet::Safeguard">Safeguard</a></div><div class="desc docblock-short">Safeguard to prevent unwanted operations in production.
Kept as a storage without extrinsic setter, so we can still enable it for some
chain-fork debugging if required.</div></li><li><div class="item-name"><a class="type" href="type.StakerInfo.html" title="type pallet_dapp_staking::pallet::StakerInfo">StakerInfo</a></div><div class="desc docblock-short">Information about how much each staker has staked for each smart contract in some period.</div></li><li><div class="item-name"><a class="type" href="type.StaticTierParams.html" title="type pallet_dapp_staking::pallet::StaticTierParams">StaticTierParams</a></div><div class="desc docblock-short">Static tier parameters used to calculate tier configuration.</div></li><li><div class="item-name"><a class="type" href="type.TierConfig.html" title="type pallet_dapp_staking::pallet::TierConfig">TierConfig</a></div><div class="desc docblock-short">Tier configuration user for current &amp; preceding eras.</div></li></ul></section></div></main></body></html>